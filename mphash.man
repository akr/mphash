.TH MPHASH 1 "February 2008" "mphash 0.1" "User Commands"
.SH NAME
mphash \- minimal perfect hash generator

.SH SYNOPSIS
.B mphash
.RI [ OPTION ]...
.RI [ FILE ]

.SH DESCRIPTION
.PP
Generate a minimal perfect hash.
.B mphash
generates self-containing source code written in C language from list of keys or key-value pairs, by default.
The list is specified by
.B FILE
or standard input.
Each line of the
.B FILE
should conatains one or two words corresponding to key or key-value pair.
The key and value is separated by spaces.
C style double quoted string can be used to specify a string which contains a space.
The generated source code is printed to standard output except
.B -o
option is specified.
.PP
.B mphash
provides options for generating a reusable library:
.B -t
for hash table and
.B -f
for hash function.
By default, they generate a file containing
generated parameter and its driver function.
However
.B -p 
specifies to generate parameter only.
.B -c
is used to generate the driver for the parameter separately.
.B -p
and
.B -c
is used for multiple hash tables and functions without duplicating the driver.
Header files for generated code is generated by
.BR -H.

.SH OPTIONS
.TP
-f, --function
generate a hash function library.
The function name generated is
.IR mphf ()
by default.
If
.B -p
is combined,
.I mphf_param
is generated instead.

.TP
-t, --table
generate a hash table library.
The function name generated is
.IR mpht ()
by default.
If
.B -p
is combined,
.I mpht_param
is generated instead.

.TP
-p, --param
generate parameter only.
It should be combined with a driver generated by
.BR -c .

.TP
-c, --code
generate common driver code for parameter by -p.
It generates
.BR mphash_table_lookup ()
and
.BR mphash_generic ().
The input file is not used when
.B -c
is specified.

.TP
-H, --header
generate a header file.
.B -H
is used as combination of code generation options as:
.BR -fH ,
.BR -tH ,
.BR -fpH ,
.BR -tpH ,
.BR -cH .
The input file is not used when
.B -H
is specified.

.TP
--static
make all definitions static.
It also disables
.B #include
directive.
It is intended for including generated files in appropriate order.

.TP
-o OUTPUT, --output=OUTPUT
specify output filename.

.TP
-n NAME, --name=NAME
specify function/parameter name.


.SH OPTION COMBINATIONS
.B mphash
supports several usecases.

.TP
self-contained test command
If neither
.B -t
nor
.B -f
are given,
a source code for self-contained test command is generated.

  mphash -o command.c dictfile
  mphash -o command.c keyfile

.TP
single hash table
.B -t
without
.B -p
is used for generating signle hash table.

  mphash -tH [-n table_funcname] -o table.h
  mphash -t [-n table_funcname] -o table.c dictfile

.TP
single hash function
.B -t
without
.B -p
is used for generating signle hash function.

  mphash -fH [-n hash_funcname] -o hash.h
  mphash -f [-n hash_funcname] -o hash.c keyfile

.TP
multiple hash tables/functions
.B -p
and
.B -c
are used for generating multiple hash tables and functions.
.B -c
generates common driver code and
.B -p
generates a parameter for the driver.

  mphash -cH -o mphash.h
  mphash -c -o mphash.c
  mphash -tpH [-n table_paramname] -o tparam.h
  mphash -tp [-n table_paramname] -o tparam.h dictfile
  mphash -fpH [-n hash_paramname] -o hparam.h
  mphash -fp [-n hash_paramname] -o hparam.h keyfile

.SH USAGE
The input file consists of one or two words for each line:

  key1
  key2
  key3
  ...

or

  key1 value1
  key2 value2
  key3 value3
  ...

Empty lines are ignored.

Former key-only file (keyfile) is used for hash functions.
A hash function maps a key to an integer.

Later key-value pairs file (dictfile) is used for hash table.
A hash table maps a key to a value.

If key or value is quoted by double quotes,
it is interpreted with escape sequences.

  "\e[1mbold\e[m"

The escape sequences recognized are:
.BR \et ,
.BR \en ,
.BR \er ,
.BR \ef ,
.BR \eb ,
.BR \ea ,
.BR \eb ,
.BR \ee ,
.BR \e\e ,
.BR \e" ,
.BI \e ooo
and
.BI \ex hh.

.SH EXAMPLES

.B mphash
without options generates a source for test command.
The generated source file can be compiled to a command.

  % cat dictfile 
  foo hoge
  bar fuga
  baz moge
  qux muga
  % mphash dictfile > tst.c
  % gcc tst.c 

The compiled command without options lists assigned hash codes, keys and values as follows.

  % ./a.out 
  2 "foo" "hoge"
  1 "bar" "fuga"
  3 "baz" "moge"
  0 "qux" "muga"

The hash codes 0 to 3 is assigned to four keys.

If arguments are given, corresponding value is lookuped.

  % ./a.out bar
  1 "fuga"
  % ./a.out foo qux
  2 "hoge"
  0 "muga"

It is not an error to give an argument which is not a key.
In such case, hashcode may be assigned range or 4294967295.

  % ./a.out a b c d e
  4294967295 not found
  3 not found
  1 not found
  4294967295 not found
  0 not found

.B mphash
can be used for large sets such as /usr/share/dict/words.

  % wc -w /usr/share/dict/words    
  98568 /usr/share/dict/words
  % mphash /usr/share/dict/words > words.c
  % gcc words.c 
  % ./a.out|sort -n|tail
  98558 "licorice's"
  98559 "neodymium's"
  98560 "Nader's"
  98561 "begotten"
  98562 "Tehran"
  98563 "spunks"
  98564 "druids"
  98565 "glowworms"
  98566 "moralizes"
  98567 "verdigris's"

mphash assigns integers 0 to 98567 for 98568 words.

.SH LIBRARY GENERATION EXAMPLE

.B "mphash -f"
generates a hash function as a library.
The generated code provides a function
.IR mphf ().

  % mphash -f /usr/share/dict/words -o wordhash.c
  % mphash -fH -o wordhash.h     
  % cat wordhash.h 
  /* This file is public domain. */

  #include <stddef.h>
  #include <stdint.h>

  extern
  uint32_t mphf(const void *key, size_t length);

  % cat tst.c 
  #include <stdio.h>
  #include <string.h>
  #include "wordhash.h"
  int main(int argc, char **argv)
  {
    int i;
    for (i = 1; i < argc; i++)
      printf("%d\n", mphf(argv[i], strlen(argv[i])));
    return 0;
  }
  % gcc -c tst.c
  % gcc -c wordhash.c 
  % gcc tst.o wordhash.o 
  % ./a.out druids 999 1000
  98564
  56383
  4294967295

For non-key strings,
.IR mphf ()
may return 4294967295.

.SH AUTHOR
Tanaka Akira

.SH SEE ALSO
.BR gperf (1),
.BR cmph (1)
