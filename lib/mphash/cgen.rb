# mphash.rb - minimal perfect hash library
#
# Copyright (C) 2008 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'erb'
require 'enumerator'

class MPHash
  def MPHash.gen_c_code(keys)
    h = MPHash::MPHF.new(keys)
    range = h.instance_variable_get(:@range)
    hashtuple = h.instance_variable_get(:@hashtuple)
    salts = hashtuple.instance_variable_get(:@salt)
    g = h.instance_variable_get(:@g)
    packed_g = []
    g.each_slice(16) {|vs|
      vs << 0 while vs.length < 16
      vs.reverse!
      packed_g << vs.inject(0) {|r, v| r * 4 + v }
    }
    formatted_g = packed_g.map {|v| "0x%x, " % v }
    formatted_g.last.sub!(/, /, '')
    ranking = h.instance_variable_get(:@ranking)
    formatted_ranking = ranking.map {|v| "0x%x, " % v }
    formatted_ranking.last.sub!(/, /, '')

    ERB.new(TEMPLATE_C, nil, '%').result(binding)
  end

  TEMPLATE_C = <<'End'
/* This file is generated by mphash. */
/* public domain */

<%= MPHash::JENKINS_LOOKUP3 %>

static struct {
  uint32_t range;
  uint32_t salt0, salt1, salt2;
  uint32_t g[<%= (g.length + 15) / 16 %>];
  uint32_t ranking[<%= ranking.length %>];
} mphf_parameter = {
  <%= range %>,
  <%= salts[0] %>, <%= salts[1] %>, <%= salts[2] %>,
  {
% formatted_g.each_slice(4) {|vs|
    <%= vs.join('') %>
% }
  },
  {
% formatted_ranking.each_slice(4) {|vs|
    <%= vs.join('') %>
% }
  }
};

#define RANK_BLOCKSIZE <%= MPHash::MPHF::RANK_BLOCKSIZE %>

#define GCC_VERSION_BEFORE(major, minor, patchlevel) \
  (defined(__GNUC__) && !defined(__INTEL_COMPILER) && \
   ((__GNUC__ < (major)) ||  \
    (__GNUC__ == (major) && __GNUC_MINOR__ < (minor)) || \
    (__GNUC__ == (major) && __GNUC_MINOR__ == (minor) && __GNUC_PATCHLEVEL__ < (patchlevel))))


#if defined(__GNUC__) && !GCC_VERSION_BEFORE(3,4,0)
# define popcount(w) __builtin_popcountl(w)
#else
# error "popcount not implemented"
#endif

#define GPOPCOUNT(w) popcount(((w) & 0x55555555) & ((w) >> 1))

static unsigned long mphf(const void *key, size_t length)
{
    uint32_t fullhash0, fullhash1, fullhash2;
    uint32_t h[3];
    uint32_t ph, mph, a, *p, mask;
    int i;
    fullhash0 = mphf_parameter.salt0;
    fullhash1 = mphf_parameter.salt1;
    hashlittle2(key, length, &fullhash0, &fullhash1);
    fullhash2 = hashlittle(key, length, mphf_parameter.salt2);
    h[0] = fullhash0 % mphf_parameter.range;
    h[1] = (fullhash1 % mphf_parameter.range) + mphf_parameter.range;
    h[2] = (fullhash2 % mphf_parameter.range) + mphf_parameter.range*2;
    i = ((mphf_parameter.g[h[0] / 16] >> (2 * (h[0] % 16))) & 0x3) +
        ((mphf_parameter.g[h[1] / 16] >> (2 * (h[1] % 16))) & 0x3) +
        ((mphf_parameter.g[h[2] / 16] >> (2 * (h[2] % 16))) & 0x3);
    ph = h[i % 3];
    a = ph / RANK_BLOCKSIZE;
    mph = mphf_parameter.ranking[a];
    p = &mphf_parameter.g[a * RANK_BLOCKSIZE / 16];
    ph %= RANK_BLOCKSIZE;
    mask = (ph%16) == 0 ? 0 : (1 << ((ph%16) * 2)) - 1;
    mph += (ph%16) - GPOPCOUNT(p[ph / 16] & mask);
    switch (ph / 16) {
      case 15: mph += 16 - GPOPCOUNT(p[14]);
      case 14: mph += 16 - GPOPCOUNT(p[13]);
      case 13: mph += 16 - GPOPCOUNT(p[12]);
      case 12: mph += 16 - GPOPCOUNT(p[11]);
      case 11: mph += 16 - GPOPCOUNT(p[10]);
      case 10: mph += 16 - GPOPCOUNT(p[9]);
      case 9: mph += 16 - GPOPCOUNT(p[8]);
      case 8: mph += 16 - GPOPCOUNT(p[7]);
      case 7: mph += 16 - GPOPCOUNT(p[6]);
      case 6: mph += 16 - GPOPCOUNT(p[5]);
      case 5: mph += 16 - GPOPCOUNT(p[4]);
      case 4: mph += 16 - GPOPCOUNT(p[3]);
      case 3: mph += 16 - GPOPCOUNT(p[2]);
      case 2: mph += 16 - GPOPCOUNT(p[1]);
      case 1: mph += 16 - GPOPCOUNT(p[0]);
      case 0: ;
    }
    return mph;
}

#if 0
int main(int argc, char **argv)
{
  uint32_t h1;
% keys.each {|k| 
  h1 = phf(<%=k.dump%>, <%=k.length%>);
  if (h1 != <%=h.phf(k).to_s%>)
    printf("bug:phf: %s : expected:%u but:%u\n", <%=k.dump%>, <%=h.mphf(k).to_s%>, h1);
  h1 = mphf(<%=k.dump%>, <%=k.length%>);
  if (h1 != <%=h.mphf(k).to_s%>)
    printf("bug:mphf: %s : expected:%u but:%u\n", <%=k.dump%>, <%=h.mphf(k).to_s%>, h1);
% }
  return 0;
}
#endif
End
end

